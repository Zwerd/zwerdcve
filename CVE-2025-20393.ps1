<#
.SYNOPSIS
    Safe Exposure Checker for CVE-2025-20393 (Cisco ESA/SMA)
    PowerShell script based on the CVE version for the Python scanner.

.DESCRIPTION
    Checks target IP/Domains for specific indicators related to Cisco Secure Email Gateway vulnerabilities.

.EXAMPLE
    .\CiscoVulnChecker.ps1 -Targets "192.168.1.1", "10.0.0.5"
    .\CiscoVulnChecker.ps1 -Targets "@targets.txt" -Ports 443,8443
#>

param(
    [Parameter(Mandatory=$true, Position=0)]
    [string[]]$Targets,

    [int[]]$Ports = @(443, 80, 8443),

    [int]$TimeoutSec = 15
)

# --- Configuration & Constants ---

$CommonPaths = @(
    "/", "/login", "/quarantine", "/spamquarantine", "/quarantine/login.cgi",
    "/cgi-bin/quarantine", "/esa/login.cgi", "/sma/login.cgi"
)

$VulnIndicators = @(
    "cisco", "asyncos", "ironport", "spam quarantine", "secure email gateway",
    "esa", "sma", "quarantine", "email security appliance"
)

# --- SSL Validation Bypass (Equivalent to verify=False) ---
if ([System.Net.ServicePointManager]::SecurityProtocol -notmatch 'Tls12') {
    [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12
}
# Disable certificate validation callback
[System.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true}

# --- Helper Functions ---

function Check-Target {
    param (
        [string]$Target,
        [int]$Port
    )

    $scheme = if ($Port -in 443, 8443) { "https" } else { "http" }
    
    # --- FIX IS HERE ---
    $baseUrl = "{0}://{1}:{2}" -f $scheme, $Target, $Port
    # -------------------

    $isVulnerable = $false

    try {
        foreach ($path in $CommonPaths) {
            $url = "$baseUrl$path"
            
            try {
                $response = Invoke-WebRequest -Uri $url -TimeoutSec $TimeoutSec -UseBasicParsing -ErrorAction Stop
            }
            catch [System.Net.WebException] {
                $response = $_.Exception.Response
                if ($null -eq $response) { continue }
            }
            catch {
                continue
            }

            $statusCode = [int]$response.StatusCode
            if ($statusCode -in 200, 401, 403) {
                
                if ($response.GetType().Name -eq "HttpWebResponse") {
                    $stream = $response.GetResponseStream()
                    $reader = New-Object System.IO.StreamReader($stream)
                    $textContent = $reader.ReadToEnd().ToLower()
                    $headers = ($response.Headers | Out-String).ToLower()
                }
                else {
                    $textContent = $response.Content.ToLower()
                    $headers = ($response.Headers | Out-String).ToLower()
                }

                $title = ""
                if ($textContent -match "<title>(.*?)</title>") {
                    $title = $matches[1].ToLower()
                }

                $foundIndicators = @()
                foreach ($ind in $VulnIndicators) {
                    if ($textContent.Contains($ind) -or $headers.Contains($ind) -or $title.Contains($ind)) {
                        $foundIndicators += $ind
                    }
                }

                if ($foundIndicators.Count -gt 0) {
                    Write-Host "âš ï¸ HIGH RISK: $url -> Potentially Exposed to CVE-2025-20393!" -ForegroundColor Red
                    Write-Host "   Detected Indicators: $($foundIndicators -join ', ')" -ForegroundColor Yellow
                    Write-Host "   ðŸš¨ IMMEDIATELY restrict external access and apply Cisco mitigations!" -ForegroundColor Red
                    $isVulnerable = $true
                    break 
                }
            }
        }

        if (-not $isVulnerable) {
            Write-Host "âœ… $baseUrl -> No vulnerable indicators found (Likely Safe)" -ForegroundColor Green
        }

    }
    catch {
        Write-Host "âŒ $baseUrl -> Error/Reachable Issue: $($_.Exception.Message) (Likely Safe or Offline)" -ForegroundColor DarkGray
    }
}

# --- Main Execution ---

# Process Targets Input (Handle @file.txt syntax)
$FinalTargets = @()

foreach ($t in $Targets) {
    if ($t.StartsWith("@")) {
        $filePath = $t.Substring(1)
        if (Test-Path $filePath) {
            $FinalTargets += Get-Content $filePath | Where-Object { $_ -match "\S" }
        } else {
            Write-Warning "File not found: $filePath"
        }
    } else {
        $FinalTargets += $t
    }
}

Write-Host "ðŸš€ Scanning $($FinalTargets.Count) target(s) on ports $($Ports -join ',')..." -ForegroundColor Cyan
Write-Host ""

# Loop through targets
# NOTE: To mimic Python threading efficiently in PowerShell 7, use: $FinalTargets | ForEach-Object -Parallel { ... }
# The below loop is sequential for compatibility with PowerShell 5.1

foreach ($tgt in $FinalTargets) {
    foreach ($p in $Ports) {
        Check-Target -Target $tgt -Port $p
    }
}

Write-Host "`nâœ… Scan Complete! If HIGH RISK detected -> Act NOW to secure your appliances!" -ForegroundColor Cyan
